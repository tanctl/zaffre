// Adapted from https://github.com/Lightprotocol/groth16-solana (Apache 2.0 License)
// Modified by Matthew Klein on 2025-11-26.

//! Provides core logic for Gnark verification
use crate::{
    commitments::{batch_verify_pedersen, get_challenge},
    error::GnarkError,
    proof::GnarkProof,
    syscalls::{alt_bn128_addition, alt_bn128_multiplication, alt_bn128_pairing},
    vk::GnarkVerifyingkey,
    witness::GnarkWitness,
};

use ark_ff::PrimeField;

use solana_bn254::AltBn128Error;
use std::ops::Neg;

/// A verifier for Gnark-generated groth16 proofs
pub struct GnarkVerifier<'a, const NR_INPUTS: usize> {
    verifyingkey: &'a GnarkVerifyingkey<'a>,
}

impl<const NR_INPUTS: usize> GnarkVerifier<'_, NR_INPUTS> {
    /// Constructs a new verifier from a verifying key
    pub fn new<'a>(verifyingkey: &'a GnarkVerifyingkey<'a>) -> GnarkVerifier<'a, NR_INPUTS> {
        GnarkVerifier { verifyingkey }
    }

    /// Verifies a Groth16 proof (as generated by Gnark) against the provided
    /// public witness.
    ///
    /// Returns `Ok(())` if verification succeeds, otherwise returns an error.
    ///
    /// # Verification Equation
    ///
    /// The verifier checks the standard Groth16 pairing equation:
    ///
    /// $$
    /// e(A, B)
    /// \cdot
    /// e(-\alpha, \beta)
    /// \cdot
    /// e(K_x, -\gamma)
    /// \cdot
    /// e(C, -\delta)
    /// =1,
    /// $$
    ///
    /// where:
    /// - $A, B, C$ are the proof elements;
    /// - $K_x$ is the prepared public-input point computed from the witness;
    /// - $\alpha, \beta, \gamma, \delta$ come from the verifying key;
    /// - and $e(\cdot,\cdot)$ is the bilinear pairing on BN254.
    ///
    /// # Commitment Verification
    ///
    /// If the verifying key includes commitment keys, the verifier derives a
    /// Fiat–Shamir challenge and batch-verifies the Pedersen openings before
    /// proceeding to the pairing check.
    ///
    /// # Result
    ///
    /// The proof is accepted if and only if the above product of pairings equals
    /// the identity element in the target group.
    pub fn verify(
        &mut self,
        proof: GnarkProof,
        public_witness: GnarkWitness<NR_INPUTS>,
    ) -> Result<(), GnarkError> {
        let mut public_witness_vec = public_witness.entries.to_vec();
        if !self.verifyingkey.commitment_keys.is_empty() {
            let challenge = get_challenge::<NR_INPUTS>(
                self.verifyingkey.public_and_commitment_committed,
                proof.commitments,
                &mut public_witness_vec,
            )?;

            batch_verify_pedersen(
                self.verifyingkey.commitment_keys,
                proof.commitments,
                &proof.commitment_pok,
                challenge,
            )?;
        }

        let prepared_public_inputs = self.prepare_inputs(&public_witness_vec, proof.commitments)?;
        let vk_alpha_neg = negate_g1(self.verifyingkey.alpha_g1)?;
        let vk_gamma_neg = g2_from_bytes(&self.verifyingkey.gamma_g2).neg();
        let vk_delta_neg = g2_from_bytes(&self.verifyingkey.delta_g2).neg();

        // Makes the assertion:
        //
        //     e(A, B) * e(-α, β) * e(K_x, -γ) * e(C, -δ) = 1
        //
        // where A, B, C are the proof elements, K_x is the prepared public inputs point,
        // and α, β, γ, δ are verifying key elements.
        let pairing_input = [
            proof.ar.as_slice(),
            proof.bs.as_slice(),
            &vk_alpha_neg,
            self.verifyingkey.beta_g2.as_slice(),
            prepared_public_inputs.as_slice(),
            g2_to_bytes(&vk_gamma_neg).as_slice(),
            proof.krs.as_slice(),
            g2_to_bytes(&vk_delta_neg).as_slice(),
        ]
        .concat();

        let pairing_res = alt_bn128_pairing(pairing_input.as_slice())
            .map_err(|_| GnarkError::ProofVerificationFailed)?;

        // The alt_bn128_pairing function returns 1 if the pairing results in unity
        // and zero otherwise
        if pairing_res[31] != 1 {
            return Err(GnarkError::ProofVerificationFailed);
        }
        Ok(())
    }

    /// Computes the linear combination of the verifying key vector `k` with the
    /// provided public inputs, and then adds the supplied G1 commitments, as
    /// required for Groth16 verification.
    ///
    /// Formally, this computes:
    ///
    /// $$
    /// P = k_0 + \sum_{i=1}^{n} x_i \cdot k_i + \sum_{j} C_j,
    /// $$
    ///
    /// where:
    /// - $x_i$ are the public inputs,
    /// - $k_i$ are the verifying-key G1 elements,
    /// - $C_j$ are the proof’s G1 commitments,
    /// - and $P$ corresponds to the Rust variable `prepared_public_inputs`.
    ///
    /// Here:
    /// - Scalar multiplication on the BN254 curve is denoted by juxtaposition
    ///   (e.g., $x_i k_i$),
    /// - Group addition in $\mathrm{G1}$ is denoted by $+$.
    ///
    /// The result is returned as a 64-byte big-endian encoding of the resulting
    /// BN254 G1 point.
    ///
    /// # Errors
    /// Returns a `GnarkError` if any G1 multiplication or addition operation
    /// fails.
    fn prepare_inputs(
        &mut self,
        public_inputs: &[[u8; 32]],
        proof_commitments: &[[u8; 64]],
    ) -> Result<[u8; 64], GnarkError> {
        let mut prepared_public_inputs = self.verifyingkey.k[0];

        for (i, input) in public_inputs.iter().enumerate() {
            // Avoid per-iteration heap allocations: build syscall inputs on the stack.
            let mut mul_input = [0u8; 96];
            mul_input[..64].copy_from_slice(&self.verifyingkey.k[i + 1]);
            mul_input[64..96].copy_from_slice(input);
            let mul_res =
                alt_bn128_multiplication(&mul_input).map_err(|_| GnarkError::PreparingInputsG1MulFailed)?;

            let mut add_input = [0u8; 128];
            add_input[..64].copy_from_slice(&mul_res);
            add_input[64..].copy_from_slice(&prepared_public_inputs);
            let add_res =
                alt_bn128_addition(&add_input).map_err(|_| GnarkError::PreparingInputsG1AdditionFailed)?;
            prepared_public_inputs = add_res;
        }

        for commitment in proof_commitments.iter() {
            let mut add_input = [0u8; 128];
            add_input[..64].copy_from_slice(commitment);
            add_input[64..].copy_from_slice(&prepared_public_inputs);
            let add_res =
                alt_bn128_addition(&add_input).map_err(|_| GnarkError::PreparingInputsG1AdditionFailed)?;
            prepared_public_inputs = add_res;
        }

        Ok(prepared_public_inputs)
    }
}

/// Construct an arkworks bn254 g2 extension from bytes
/// Needed to perform any operations not supported by solana system calls
pub(crate) fn g2_from_bytes(be_bytes: &[u8; 128]) -> ark_bn254::G2Affine {
    let x_1 = ark_bn254::Fq::from_be_bytes_mod_order(&be_bytes[0..32]);
    let x_0 = ark_bn254::Fq::from_be_bytes_mod_order(&be_bytes[32..64]);
    let y_1 = ark_bn254::Fq::from_be_bytes_mod_order(&be_bytes[64..96]);
    let y_0 = ark_bn254::Fq::from_be_bytes_mod_order(&be_bytes[96..128]);

    let x =
        ark_ff::QuadExtField::<ark_ff::Fp2ConfigWrapper<ark_bn254::Fq2Config>> { c0: x_0, c1: x_1 };
    let y =
        ark_ff::QuadExtField::<ark_ff::Fp2ConfigWrapper<ark_bn254::Fq2Config>> { c0: y_0, c1: y_1 };

    ark_bn254::G2Affine {
        x,
        y,
        infinity: false,
    }
}

/// Writes an arkworks bn254 g2 extension element to big endian bytes
pub(crate) fn g2_to_bytes(point: &ark_bn254::G2Affine) -> [u8; 128] {
    use ark_ff::BigInteger;

    // Ensure it's not the point at infinity
    assert!(!point.infinity, "cannot serialize point at infinity");

    // Each coordinate is in Fq2 = (c0 + c1 * u)
    // and each c0/c1 is an Fq element (32 bytes when to_bytes_be())
    let x_0_bytes = point.x.c0.into_bigint().to_bytes_be();
    let x_1_bytes = point.x.c1.into_bigint().to_bytes_be();
    let y_0_bytes = point.y.c0.into_bigint().to_bytes_be();
    let y_1_bytes = point.y.c1.into_bigint().to_bytes_be();

    // Concatenate in the same order as your g2_from_bytes expects:
    // [x_1 | x_0 | y_1 | y_0]
    let mut out = [0u8; 128];
    out[0..32].copy_from_slice(&x_1_bytes);
    out[32..64].copy_from_slice(&x_0_bytes);
    out[64..96].copy_from_slice(&y_1_bytes);
    out[96..128].copy_from_slice(&y_0_bytes);
    out
}

/// Returns -g1 in bytes, using solana system calls
fn negate_g1(g1_element: [u8; 64]) -> Result<[u8; 64], AltBn128Error> {
    // bytes corresponding to -1 in the bn254 scalr field
    let neg_one: [u8; 32] = [
        48, 100, 78, 114, 225, 49, 160, 41, 184, 80, 69, 182, 129, 129, 88, 93, 40, 51, 232, 72,
        121, 185, 112, 145, 67, 225, 245, 147, 240, 0, 0, 0,
    ];

    let mut operands = [0u8; 96];
    operands[..64].copy_from_slice(&g1_element[..]);
    operands[64..96].copy_from_slice(&neg_one);
    alt_bn128_multiplication(&operands)
}
