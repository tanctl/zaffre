//! Provides functionality for reading Gnark generated verification keys
//! and for writing them in a rust file

use std::fs::File;
use std::io::{self, Read, Write};
use std::mem::size_of;
use std::path::Path;

/// Verifying key for a Gnark-flavoured Groth16 zero-knowledge proof.
pub struct GnarkVerifyingkey<'a> {
    /// Number of public inputs for the circuit.
    pub nr_pubinputs: usize,

    /// α element in G1.
    pub alpha_g1: [u8; 64],

    /// β element in G2.
    pub beta_g2: [u8; 128],

    /// γ element in G2 .
    pub gamma_g2: [u8; 128],

    /// δ element in G2 .
    pub delta_g2: [u8; 128],

    /// Linear combination keys for public inputs (G1 elements).
    pub k: &'a [[u8; 64]],

    /// Precomputed commitment (each a pair of 2 G2 elements)
    pub commitment_keys: &'a [[u8; 256]],

    /// For each commitment, the public variables that are part of the commitment.
    pub public_and_commitment_committed: &'a [&'a [u64]],
}

/// This takes a source file, generated by Gnark's `WriteRawTo` function
/// and writes corresponding rust code to the `target_file`
pub fn generate_key_file(source_file: &str, target_file: &str) -> io::Result<()> {
    let file = File::open(source_file)?;
    let vk = parse_vk(file)?;
    write_vk_const_file(&vk, target_file)
}

/// Parses a gnark generated verification key into the local Gnark type
pub(crate) fn parse_vk<'a, R: Read>(mut reader: R) -> io::Result<GnarkVerifyingkey<'a>> {
    let mut vk_alpha_g1 = [0u8; 64];
    reader.read_exact(&mut vk_alpha_g1)?;
    let mut vk_beta_g1 = [0u8; 64];
    reader.read_exact(&mut vk_beta_g1)?;
    let mut vk_beta_g2 = [0u8; 128];
    reader.read_exact(&mut vk_beta_g2)?;
    let mut vk_gamma_g2 = [0u8; 128];
    reader.read_exact(&mut vk_gamma_g2)?;
    let mut vk_delta_g1 = [0u8; 64];
    reader.read_exact(&mut vk_delta_g1)?;
    let mut vk_delta_g2 = [0u8; 128];
    reader.read_exact(&mut vk_delta_g2)?;

    // Read the IC vector
    let vk_ic_vec = read_vk_ic(&mut reader)?;
    let vk_ic_slice: &'static [[u8; 64]] = Box::leak(vk_ic_vec.into_boxed_slice());

    let public_committed_data = read_matrix(&mut reader)?;
    let borrowed: Vec<&'static [u64]> = public_committed_data
        .into_iter()
        .map(|v| Box::leak(v.into_boxed_slice()) as &'static [u64])
        .collect();
    let public_and_commitment_committed = Box::leak(borrowed.into_boxed_slice());

    let nb_commitment_keys = read_u32(&mut reader)?;
    let commitment_keys_vec = read_commitment_keys(&mut reader, nb_commitment_keys)?;
    let commitment_keys = Box::leak(commitment_keys_vec.into_boxed_slice());

    let vk = GnarkVerifyingkey {
        nr_pubinputs: vk_ic_slice
            .len()
            .saturating_sub(1)
            .saturating_sub(commitment_keys.len()),
        alpha_g1: vk_alpha_g1,
        beta_g2: vk_beta_g2,
        gamma_g2: vk_gamma_g2,
        delta_g2: vk_delta_g2,
        k: vk_ic_slice,
        public_and_commitment_committed,
        commitment_keys,
    };

    Ok(vk)
}

pub(crate) fn read_vk_ic(mut reader: impl Read) -> io::Result<Vec<[u8; 64]>> {
    let count = read_u32(&mut reader)?;

    // Prepare storage for that many 64-byte entries
    let mut vk_ic = Vec::with_capacity(count as usize);
    let mut buf = [0u8; 64];

    for _ in 0..count {
        reader.read_exact(&mut buf)?;
        vk_ic.push(buf);
    }

    Ok(vk_ic)
}

fn read_matrix(reader: &mut impl Read) -> io::Result<Vec<Vec<u64>>> {
    let outer_len = read_u32(reader)?;

    let mut result = Vec::with_capacity(outer_len as usize);
    for _ in 0..outer_len {
        let inner_len = read_u32(reader)? as usize;
        let mut inner = vec![0u64; inner_len];

        // Read all inner elements
        for elem in &mut inner {
            *elem = read_u64(reader)?;
        }

        result.push(inner);
    }

    Ok(result)
}

fn read_commitment_keys(
    reader: &mut impl Read,
    nb_commitment_keys: u32,
) -> io::Result<Vec<[u8; 256]>> {
    let mut result = Vec::with_capacity(nb_commitment_keys as usize);
    for _ in 0..nb_commitment_keys {
        let mut key = [0u8; 256];
        reader.read_exact(&mut key)?;
        result.push(key);
    }

    Ok(result)
}

// Helper to read a u64 (little-endian)
fn read_u64(reader: &mut impl Read) -> io::Result<u64> {
    let mut buf = [0u8; size_of::<u64>()];
    reader.read_exact(&mut buf)?;
    Ok(u64::from_be_bytes(buf))
}

fn read_u32(reader: &mut impl Read) -> io::Result<u32> {
    let mut buf = [0u8; 4];
    reader.read_exact(&mut buf)?;
    Ok(u32::from_be_bytes(buf))
}

/// Reads the main verifier file, appends the generated verifying key constant,
/// and writes the combined output to a new target file without modifying the original.
fn write_vk_const_file<P: AsRef<Path>>(vk: &GnarkVerifyingkey, target_file: P) -> io::Result<()> {
    // Create a new file for the combined output
    let mut f = File::create(&target_file)?;

    // Add a clear separator
    writeln!(f, "// === Auto-generated verifying key constant ===")?;
    writeln!(f, "use gnark_verifier_solana::vk::GnarkVerifyingkey;")?;
    // Helper function to format byte arrays as hex
    fn fmt_byte_array(bytes: &[u8]) -> String {
        let mut s = String::from("[");
        for (i, b) in bytes.iter().enumerate() {
            if i > 0 {
                s.push_str(", ");
            }
            s.push_str(&format!("0x{:02x}", b));
        }
        s.push(']');
        s
    }

    fn fmt_u64_array(nums: &[u64]) -> String {
        let mut s = String::from("[");
        for (i, n) in nums.iter().enumerate() {
            if i > 0 {
                s.push_str(", ");
            }
            s.push_str(&format!("0x{:016x}", n));
        }
        s.push(']');
        s
    }

    writeln!(f, "#[rustfmt::skip]")?;
    // Write out the verifying key constant
    writeln!(
        f,
        "pub const VK: GnarkVerifyingkey<'static> = GnarkVerifyingkey {{"
    )?;
    writeln!(f, "    nr_pubinputs: {},", vk.nr_pubinputs)?;
    writeln!(f, "    alpha_g1: {},", fmt_byte_array(&vk.alpha_g1))?;
    writeln!(f, "    beta_g2: {},", fmt_byte_array(&vk.beta_g2))?;
    writeln!(f, "    gamma_g2: {},", fmt_byte_array(&vk.gamma_g2))?;
    writeln!(f, "    delta_g2: {},", fmt_byte_array(&vk.delta_g2))?;

    writeln!(f, "    k: &[")?;
    for entry in vk.k {
        writeln!(f, "        {},", fmt_byte_array(entry))?;
    }
    writeln!(f, "    ],")?;

    writeln!(f, "    commitment_keys: &[")?;
    for entry in vk.commitment_keys {
        writeln!(f, "        {},", fmt_byte_array(entry))?;
    }
    writeln!(f, "    ],")?;

    writeln!(f, "    public_and_commitment_committed: &[")?;
    for entry in vk.public_and_commitment_committed {
        writeln!(f, "        &{},", fmt_u64_array(entry))?;
    }
    writeln!(f, "    ],")?;
    writeln!(f, "}};")?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::parse_vk;
    use std::{fs::File, io};

    #[test]
    fn test_parse_vk_no_commitment() -> io::Result<()> {
        // Open the test file
        let file = File::open("src/test_files/sum_a_b.vk")?;

        // Parse the verifying key
        let vk = parse_vk(file)?;

        // Check some basic properties
        assert!(!vk.k.is_empty()); // ensure vk_ic is not empty
        assert_eq!(vk.alpha_g1.len(), 64);
        assert_eq!(vk.beta_g2.len(), 128);
        assert!(vk.k.len() == 2);
        assert!(vk.commitment_keys.is_empty());
        assert!(vk.public_and_commitment_committed.is_empty());

        Ok(())
    }

    #[test]
    fn test_parse_vk_commitment() -> io::Result<()> {
        // Open the test file
        let file = File::open("src/test_files/keccak_f1600.vk")?;

        // Parse the verifying key
        let vk = parse_vk(file)?;

        // Check some basic properties
        assert!(!vk.k.is_empty()); // ensure vk_ic is not empty
        assert_eq!(vk.alpha_g1.len(), 64);
        assert_eq!(vk.beta_g2.len(), 128);
        assert!(vk.k.len() == 2);
        assert!(vk.commitment_keys.len() == 1);
        assert!(vk.public_and_commitment_committed.len() == 1);
        assert!(vk.public_and_commitment_committed[0].is_empty());
        Ok(())
    }
}
